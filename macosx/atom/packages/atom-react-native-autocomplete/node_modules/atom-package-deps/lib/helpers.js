'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.promptUser = exports.enablePackage = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var enablePackage = exports.enablePackage = function () {
  var _ref = _asyncToGenerator(function* (packageName) {
    if (atom.packages.isPackageDisabled(packageName)) {
      atom.packages.enablePackage(packageName);
    }
    if (!atom.packages.isPackageLoaded(packageName)) {
      atom.packages.loadPackage(packageName);
    }
    if (!atom.packages.isPackageActive(packageName)) {
      yield atom.packages.activatePackage(packageName);
    }
  });

  return function enablePackage(_x) {
    return _ref.apply(this, arguments);
  };
}();

var promptUser = exports.promptUser = function () {
  var _ref2 = _asyncToGenerator(function* (packageName, dependencies) {
    var configPath = _path2.default.join(atom.getConfigDirPath(), 'package-deps-state.json');
    var configFile = yield _sbConfigFile2.default.get(configPath, { ignored: [] }, { createIfNonExistent: true });
    var ignoredPackages = yield configFile.get('ignored');
    if (ignoredPackages.includes(packageName)) {
      return Promise.resolve('No');
    }

    return new Promise(function (resolve) {
      var notification = atom.notifications.addInfo(packageName + ' needs to install dependencies', {
        dismissable: true,
        icon: 'cloud-download',
        detail: dependencies.map(function (e) {
          return e.name;
        }).join(', '),
        description: 'Install dependenc' + (dependencies.length === 1 ? 'y' : 'ies') + '?',
        buttons: [{
          text: 'Yes',
          onDidClick: function onDidClick() {
            resolve('Yes');
            notification.dismiss();
          }
        }, {
          text: 'No Thanks',
          onDidClick: function onDidClick() {
            resolve('No');
            notification.dismiss();
          }
        }, {
          text: 'Never',
          onDidClick: function onDidClick() {
            configFile.append('ignored', packageName);
            if (!shownStorageInfo) {
              shownStorageInfo = true;
              atom.notifications.addInfo('How to reset package-deps memory', {
                dismissable: true,
                description: 'If you ever wish to change the packages package-deps never installs, please modify ' + (0, _tildify2.default)(configPath)
              });
            }
            resolve('Never');
            notification.dismiss();
          }
        }]
      });
      notification.onDidDismiss(function () {
        return resolve('No');
      });
    });
  });

  return function promptUser(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
}();

exports.apmInstall = apmInstall;
exports.getDependencies = getDependencies;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _tildify = require('tildify');

var _tildify2 = _interopRequireDefault(_tildify);

var _sbExec = require('sb-exec');

var _sbConfigFile = require('sb-config-file');

var _sbConfigFile2 = _interopRequireDefault(_sbConfigFile);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

var shownStorageInfo = false;
var VALID_TICKS = new Set(['âœ“', 'done']);
var VALIDATION_REGEXP = /(?:Installing|Moving) (.*?) to .* (.*)/;

function apmInstall(dependencies, progressCallback) {
  var errors = new Map();
  return Promise.all(dependencies.map(function (dependency) {
    return (0, _sbExec.exec)(atom.packages.getApmPath(), ['install', dependency.url, '--production', '--color', 'false'], {
      stream: 'both',
      ignoreExitCode: true
    }).then(function (output) {
      var successful = VALIDATION_REGEXP.test(output.stdout) && VALID_TICKS.has(VALIDATION_REGEXP.exec(output.stdout)[2]);
      progressCallback(dependency.name, successful);
      if (!successful) {
        var error = new Error('Error installing dependency: ' + dependency.name);
        error.stack = output.stderr;
        throw error;
      }
    }).catch(function (error) {
      errors.set(dependency.name, error);
    });
  })).then(function () {
    return errors;
  });
}

function getDependencies(packageName) {
  var toReturn = [];
  var packageModule = atom.packages.getLoadedPackage(packageName);
  var packageDependencies = packageModule && packageModule.metadata['package-deps'];

  if (packageDependencies) {
    var _arr = packageDependencies;

    for (var _i = 0; _i < _arr.length; _i++) {
      var entry = _arr[_i];
      var entryName = entry;
      var entryUrl = entry;

      if (entry.indexOf('#') > -1) {
        var _entry$split = entry.split('#');

        var _entry$split2 = _slicedToArray(_entry$split, 2);

        entryName = _entry$split2[0];
        entryUrl = _entry$split2[1];
      }

      if (__steelbrain_package_deps.has(entryName) || atom.packages.resolvePackagePath(entryName)) {
        continue;
      }
      __steelbrain_package_deps.add(entryName);
      toReturn.push({
        url: entryUrl,
        name: entryName
      });
    }
  } else {
    console.error('[Package-Deps] Unable to get loaded package \'' + packageName + '\'');
  }

  return toReturn;
}